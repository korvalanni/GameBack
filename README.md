# Game Server (Kotlin + WebFlux + PostgreSQL)

## Возможности

- **Создание новой игры**  
  `POST /api/new` — создаёт новую игру, принимает параметры: ширина, высота, количество мин. Возвращает `game_id`.

- **Совершение хода**  
  `POST /api/turn` — выполняет ход по переданным координатам (строка и колонка) для конкретной игры (`game_id`). Проверяет завершённость игры и корректность координат.

- **Маппинг DTO ↔ Entity**  
  Используется отдельный `GameMapper` и `ObjectMapper` для преобразования между DTO и Entity-объектами, обеспечивая чистое разделение слоёв.

- **Защита от SQL-инъекций**  
  Все запросы к базе данных выполняются через `R2dbcEntityTemplate` и `PreparedStatement`-подобный подход, что исключает возможность SQL-инъекций.

- **Liquibase**  
  Используется для управления миграциями схемы базы данных. Все изменения схемы оформлены в виде декларативных YAML-файлов и применяются автоматически при старте.

- **Интеграционные тесты с Testcontainers**  
  PostgreSQL запускается в изолированном Docker-контейнере с помощью `Testcontainers`. Это позволяет проводить изолированные и воспроизводимые тесты с использованием реальной базы данных.

- **Глобальный хэндлер ошибок**  
  Все ошибки (включая валидации, бизнес-ошибки и системные) обрабатываются централизованно в `@RestControllerAdvice`. Возвращаются стандартизированные ответы с кодом ошибки, статусом и сообщением.

## Почему WebFlux (реактивный стек)

Проект реализован с использованием **Spring WebFlux** и **R2DBC** (Reactive Relational Database Connectivity) по следующим причинам:

- **Асинхронность и масштабируемость**  
  Благодаря реактивной модели, приложение способно обрабатывать большое количество параллельных запросов без блокировок потоков, что особенно важно в случае интенсивного взаимодействия с БД.

- **Минимальные задержки I/O**  
  Обработка запросов к базе данных и внешним ресурсам не блокирует выполнение других операций, что снижает общее время отклика системы.

- **Совместимость с R2DBC**  
  В проекте используется PostgreSQL через R2DBC-драйвер, позволяющий работать с БД в неблокирующем режиме, что особенно удобно для реактивных сценариев.

- **Современный стек**  
  Подходит для микросервисной архитектуры и систем, ориентированных на высокую производительность. WebFlux предоставляет гибкую модель программирования через `Mono` и `Flux`.

## Использование Kotlin и корутин

Проект написан на **Kotlin**, что позволяет лаконично и выразительно описывать бизнес-логику, а также использовать преимущества корутин:

- **Нативная поддержка асинхронности через `suspend`-функции**  
  Корутины позволяют писать асинхронный код в императивном стиле, упрощая чтение и сопровождение. Методы в сервисах, контроллерах и репозиториях описаны как `suspend`, что позволяет эффективно использовать неблокирующую модель WebFlux.

- **Интеграция с R2DBC и WebFlux**  
  Используется `awaitSingle()` и `awaitSingleOrNull()` из `kotlinx-coroutines-reactor`, обеспечивающие взаимодействие между реактивным потоком (`Mono`, `Flux`) и корутинным миром.

- **Лёгкий поток исполнения**  
  Благодаря лёгкости корутин, приложение может масштабироваться без создания большого количества JVM-потоков. Это особенно важно для высоконагруженных сервисов.

- **Удобная тестируемость**  
  Корутины упрощают написание и выполнение end-to-end и unit-тестов. В проекте используется реактивный `WebTestClient` совместно с suspend-контекстом, что делает тесты надёжными и удобными для отладки.

Такой подход делает проект современным, эффективным и готовым к работе под высокими нагрузками с минимальными затратами на ресурсы.


## Запуск
1. Поднять базу:
```bash
docker-compose -f docker-compose-db.yml up -d
```
2. Запусти приложение:
```bash
./gradlew bootRun
```

## Запуск тестов:
```bash
./gradlew test
```

## Диаграмма последовательностей (после вызова `/turn`):

```mermaid
sequenceDiagram
    participant Client
    participant Controller
    participant Service
    participant Repository

    Client->>Controller: POST /turn (gameId, row, col)
    Controller->>Service: turn(request)
    Service->>Repository: findById(gameId)
    Repository-->>Service: GameEntity
    Service->>Service: updateField()
    Service->>Repository: save(updatedEntity)
    Repository-->>Service
    Service-->>Controller: GameInfoResponse
    Controller-->>Client: GameInfoResponse
```
